
namespace STPLib.GObj;

--=======================================
-- -- -- Interface Type

-- Predefined sides for interfaces.
enum .SIDE {
    .BIDIR = 0,
    .IN = 1,
    .OUT = 2
}

struct .InterfaceType {
    typename: string,
    
    -- Key is typically .SIDE enum value
    sides: table(any, {
        -- Allow multiple interfaces to be at this side?
        allow_many: bool,

        -- If false, .Interface:GetAttached(<key>) will return nil.
        track_connected: bool,

        -- If false or nil, no callbacks menioning interfaces of this side will be called.
        can_cause_callbacks: bool|nil = false
        -- If false or nil, no callbacks will be called on interfaces of this side
        can_receive_callbacks: bool|nil = false
    }),

    default_side: nil | <key of '.sides'>,

    -- Array that has each key from .sides
    generated sides_enum: array(any)
};

fn .RegisterType(ty: .InterfaceType)
readonly var .Types: table(typename: string, .InterfaceType)

--=======================================
-- -- -- Interface

-- Inteface automatically detaches when owner component removed.
type .Interface = {
    readonly var .TypeName: string(.InterfaceType.typename);

    readonly var .Side: <depends on '.Type'>;

    fn :GetOwner() -> .Component | nil -- nil if not valid

    fn :SetNetwork(net: .Network | nil) -> error: nil|string;
    fn :GetNetwork() -> .Network | nil;

    fn :CanAttach(val: string(.InterfaceType.typename) | .Inteface | .InterfaceType | .Network) 
        -> bool, error_reason: nil|string;

    fn :Attach(if: .Interface) -> error: nil|string;
    fn :Detach();

    fn :GetAttached(side: <depends on '.TypeName'>) -> nil | array(.Interface);

    -- Only works if .InterfaceType.sides[side] has both allow_many==false and track_connected==true
    fn :GetAttachedSingle(side: <depends on '.TypeName'>) -> nil | .Interface;


    hook :OnOtherAttached(iface: .Interface);
    hook :OnOtherPreDetached(iface: .Interface);

    hook :OnSelfAttached();
    hook :OnSelfPreDetached();

    var .Data: any|nil;

    fn :IsValid() -> bool;
    fn :Remove();

    internal fn :_Remove(component_removed: bool)
}

--=======================================
-- -- -- Component

fn .RegisterComponent(meta: .Component);
readonly var .ComponentTypes: table(typename: string, .Component);

fn .CreateComponent(type: string, params: table) -> .Component;

type .Component = metatable {
    readonly var .Type: string;

    -- For reflection, etc.
    generated readonly var .Interfaces: table(interface_name: string, .Interface)

    hook :Init(params: table);
    hook :PreRemove();

    fn :Remove();
    fn :IsValid() -> bool; -- Returns true before ':Init' hook called, false after ':PreRemove' hook finished

    fn :AddInterface(params: {
        name: string,
        type: string(.InterfaceType.typename),
        side: <depends on 'type', usually either .SIDE.BIDIR or .SIDE.IN | .SIDE.OUT>,
        data: any|nil
    });

    var .<interface_name>: .Interface;
};

--=======================================
-- -- -- Network


type .Network = {
    readonly var .TypeName: string(.InterfaceType.typename);

    fn :Connect(iface: .Interface) -> error: nil|string;
    fn :Disconnect(iface: .Interface);

    fn :CanConnect(val: string(.InterfaceType.typename) | .Inteface | .InterfaceType) 
        -> bool, error_reason: nil|string

    fn :Remove() -> bool;
    fn :IsValid() -> bool;

    fn :GetConnected(side: <depends on '.TypeName'>) -> nil | array(.Interface);

    -- Only works if .InterfaceType.sides[side] has both allow_many==false and track_connected==true
    fn :GetConnectedSingle(side: <depends on '.TypeName'>) -> nil | .Interface;

    hook :OnConnected(iface: .Interface);
    hook :OnPreDisconnected(iface: .Interface);
}

fn .CreateNetwork(iftype: string) -> .Network;