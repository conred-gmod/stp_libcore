# STPLib

hook .PreFileIncluded(filename: string, realm: "sv"|"sh"|"cl")
fn .GetRealmFromFilename(filename: string) -> "sv"|"sh"|"cl"
fn .IncludeFile(filename: string) -> file_return: ...|nil
fn .IncludeList(prefix: string, files: array(string))
fn .IncludeDir(dir: string, recursive: bool|nil=false)

fn .Error(parts: ...(any)) -- Unlike GMod Error(), this actually errors and halts execution

fn .CheckType(val: any|nil, valname: string, allowed_types: array(string)|string) -> val: any|nil

fn .RegisterType(name: string, {
    IsInstance: fn(value: any|nil) -> bool
})

fn .IsType(val: any|nil, type: string) -> bool
fn .ToString(val: any|nil, pretty_print: bool|nil = false) -> string

type .ClassIdent = string

# IGNORE [Registers type with .RegisterType]
# Each class in `parents` should be defined before this call
# If multiple parents are given, they are searched in given order 
#
# Return 1: class metatable
# Return 2: class instance constructor, supposed to be local function
# Return 3..: metatable of each parent class specified
fn .DefineClass(name: .ClassIdent, parents: array(.ClassIdent)) 
    -> <metatable>, fn(inner_data: table(any,any)) -> <class 'name' instance>, ...(<parent metas>)

# Never returns nil, can be called before .DefineClass(name, {...}) is called
fn .GetClassMeta(name: .ClassIdent) -> <metatable>

fn .GetClassName(obj: table(any,any)) -> string|nil

fn .AddIndexBefore(name: .ClassIdent, index: fn(self, key: any) -> value: any|nil)
fn .AddIndexAfter(name: .ClassIdent, index: fn(self, key: any) -> value: any|nil)


## Table utils
fn .ReverseArrayInplace(tbl: array(any))

-- `local val =  .IndexWithFill(tbl, "first", "second", 3, false)`  
-- is same as
-- `local val = tbl.first.second[3][false]`
-- but if value not exists, table value is created
fn .IndexWithFill(tbl: table, indices: ...(any)) -> any

-- `.AddToTable(tbl, "value", "k1", 2, true)`
-- is same as
-- `tbl.k1[2][true] = "value"`
-- but it creates all the intermediate tables if they not exist
fn .AddToTable(tbl: table, value: any, indices: ...(any))

-- `.AddToArray(tbl, "value", "first", 40)`
-- is same as
-- `table.insert(tbl.first[40], "value")`
-- but it creates all the intermediate tables if they not exist
fn .AddToArray(tbl: table, value: any, indices: ...(any))

-- `.RemoveFromTable(tbl, "a", "b")`
-- is same as
-- `
-- tbl.a.b = nil
-- if table.IsEmpty(a) then tbl.a = nil end
-- `
fn .RemoveFromTable(tbl, indices:)

-- Same as #tbl but has no undefined behaviour if tbl is not-sequential
fn .SeqCount(tbl: table) -> uint

-- Returns index of value in tbl
fn table.SeqFindValue(tbl: table, value: any) -> pint|nil