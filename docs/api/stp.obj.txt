namespace stp.obj;

------- Objects/Traits
interface .Object {
    const .TypeName: string,
    const .IsFullyRegistered: bool -- Modified by .BeginMeta / .Register
    const .IsTrait: bool

    if .IsTrait {
        operator .__call = stp.obj.ApplyTrait
    }

    if not .IsTrait {
        const .FinalMeta: metatable(.Object) = self
    }
}

-- Creates a stub metatable
fn .BeginObject(typename: string) -> metatable(.Object)
fn .BeginTrait(typename: string) -> metatable(.Object)

-- Makes existing metatable registrable. You need to set `.TypeName`.
fn .BeginExistingObject(meta: metatable(.Object)) -> metatable(.Object)

internal hook ._OnMetaCreated(meta: metatable(.Object))

-- Registers an object
fn .Register(meta: metatable(.Object))
hook .OnMetaRegistered(meta: metatable(.Object))

fn .GetObjectMetatables() -> table(typename: string, metatable(.Object))
fn .GetTraitMetatables() -> table(typename: string, metatable(.Object))

------- Trait application stuff
internal fn ._MergablesInit() -> table

-- `traitmeta` should be a registered trait.
-- `targetmeta` should be a not-fully-registered object or trait.
fn .ApplyTrait(traitmeta: metatable(.Object), targetmeta: metatable(.Object))

-- `meta` shoud be a non-fully-registered object/trait
-- `keyname` is a name of key that all mergables of `keyname` will be merged into.
-- `impl_name` is similar to second argument of `hook.Add`.
-- Mergables respect addition order.
fn .MergablesAdd(meta: metatable(.Object), keyname: string, impl_name: string, merger_name: string, value: any|nil)

fn .MergablesDeclare(meta: metatable(.Object), keyname: string, merger_name: string)

type .MergablesDesc = {
    .MaxIdx: uint,
    .MergerName: string
    .[impl_name: string]: {
        Idx: uint,
        Value: any|nil
    }
}

-- A low-level function.
fn .MergerRegister(name: string, fn: fn(meta: metatable(.Object), key: string, values: .MergablesDesc))

-- `array[i].Key` is an `impl_name`. Index is `Idx`, see `.MergablesDesc`
fn .MergerRegisterArray(name: string, fn: fn(
    meta: metatable(.Object), key: string, array: array({Key: string, Value: any|nil})))


------- Utilities
fn .ApplyMany(target: metatable(.Object), callables: ...fn(meta: metatable(.Object))) -> metatable(.Object)

merger CallInOrder_Member
-- values should be fn(self, ...args)
-- merged into fn(self, ...args) that calls values in addition order

------- Instantiatable Objects
trait .Initializable {
    hook :Init(args: table)
}

trait .Removable {
    impl .Initializable

    hook :OnPreRemove(cascaded: bool)
}

trait .Instantiatable {
    impl .Removable

    fn .Create(args: table) -> .Instantiatable

    fn :Remove(cascaded: bool)

    -- Object considered to be valid after :Init and before :Remove
    fn :IsValid() -> bool
}

hook .PreInit(obj: .Instantiatable, args: table)
hook .PostInit(obj: .Instantiatable, args: table)

hook .PreRemove(obj: .Instantiatable, cascaded: bool)
hook .PostRemove(obj: .Instantiatable, cascaded: bool)
------- Generic Managers
struct .ManagerDesc = {
    GenerateKey: fn(mgr: .Removable + .Manager(self), item: .Object + ManagedItem(self)) -> any,

    -- Following fields are used for generated functions' names
    ItemSg: string, -- Item name in singular
    ItemPl: string, -- Item name in plural
    ManagerSg: string, -- Manager name in singular
}

struct .ManagerData = {
    Item: metatable(.Removable + .ManagedItem(Desc)),
    Manager: metatable(.Object + .Manager(Desc)),
    Desc: .ManagerDesc
}

nonpubctor mixin(md: .ManagerDesc) .Manager {
    require .Object

    type Item: .ManagedItem(md);
    type Key;

    fn :Register{md.ItemSg}(item: Item) -> Key
    hook :OnPreRegistered{md.ItemSg}(item: Item, key: Key)
    hook :OnPostRegistered{md.ItemSg}(item: Item, key: Key)

    fn :Unregister{md.ItemSg}(item: Item)
    fn :Unregister{md.ItemSg}ByKey(key: Key)
    fn :UnregisterAll{md.ItemPl}()
    hook :OnPreUnregistered{md.ItemSg}(item: Item, key: Key)
    hook :OnPostUnregistered{md.ItemSg}(item: Item, key: Key)

    fn :GetAll{md.ItemPl}() -> table(Key, Item)

    -- If not an item, returns nil
    fn :Get{md.ItemSg}Key(item: Item|table) -> Key|nil
    -- If not a valid key, returns nil
    fn :Get{md.ItemSg}ByKey(key: Key|any) -> Item|nil
}

nonpubctor mixin(md: .ManagerDesc) .ManagedItem {
    require .Removable

    type Key;
    type Manager: .Manager(md);

    -- Following functions return nil if this item is not currently registered
    fn :GetUsed{md.ManagerSg}() -> Manager|nil
    fn :Get{md.ItemSg}Key() -> Key|nil

    
    hook :OnPreRegistered{md.ItemSg}(mgr: Manager, key: Key)
    hook :OnPostRegistered{md.ItemSg}(mgr: Manager, key: Key)
    hook :OnPreUnregistered{md.ItemSg}(mgr: Manager, key: Key)
    hook :OnPostUnregistered{md.ItemSg}(mgr: Manager, key: Key)
}

fn .MakeManager(
    item: metatable(.Removable), manager: metatable(.Object),
    desc: .ManagerDesc) -> .ManagerData

------- Trackable objects
trait .Trackable {
    impl .Instantiatable
    const .IsTrackable: bool = true
}

type .TrackId = uint23
const .TRACK_ID_BITS = 23
const .TRACK_ID_MAX: uint


fn .MakeTracker() -> .Tracker

object .Tracker  {
    impl .Instantiatable

    fn .Register(obj: .Trackable)
    fn .Unregister(obj: .Trackable)
    fn .GetAll() -> table(.)
}